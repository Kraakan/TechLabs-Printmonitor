<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dennis Printmonitor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

{#<body style="background-image: url('{{  url_for("static", filename="FallbackPortrait1.png")  }}')">#}
<body style="background-image: url('{{ url_for("static", filename="blob_scene_3.svg") }}')">
<div id="hub">
    <img src="{{ url_for('static' , filename='hub.png') }}" alt="">
</div>
<div id="bookings">

    <h1>Bookings:</h1>

</div>
<div id="printStatus">
    <h1>Printer status</h1>
    <!-- Prusa-server computer -->
    <div id="printContainer">
        <img id="printerImage" src="{{ image_url }}" alt="Printer Image">
        <div id="printMonitor">
            <p>
                <strong>Status: </strong><span id="printer-state"></span><br>
                <strong>Job: </strong> <span id="job-file-display_name"></span><br>
                <strong>Progress: </strong> <span id="job-progress"></span> %<br>
                <strong>Remaining: </strong> <span id="job-time_remaining"></span> mins<br>
                <strong>Nozzle temp: </strong> <span id="printer-temp_nozzle"></span> C<br>
                <strong>Bed temp: </strong> <span id="printer-temp_bed"></span> C<br>
                <strong>Z-height: </strong> <span id="printer-axis_z"></span> mm<br>
            </p>
        </div>
    </div>
</div>
<div id="featuredContent">
    {{ featuredContent | safe }}
</div>
<div id="joke">
    <p>{{ joke | safe }}</p>
</div>
<div id="fallback"></div>
</body>


<script>
    function fetchPrinterImage() {
        fetch('{{ image_url }}') // Prusa server computer
            .then(response => {
                if (!response.ok) {
                    throw new Error("Image data fetch failed");
                }
                return response.blob();
            })
            .then(blob => {
                const imageUrl = URL.createObjectURL(blob);
                document.querySelector("#printerImage").src = imageUrl;
            })
            .catch(error => {
                console.error('There was a problem with fetching the last webcam image:', error);
            });
    }

    // CORS redirection via localhost
    async function fetchPrinterStatus() {
        try {
            const response = await fetch('{{printer_status_url}}');
            if (!response.ok) {
                throw new Error('Printer data fetch failed');
            }
            // Wait for the promise to be resolved
            const data = await response.json();
            //  no printing running
            if (!data || !data.printer || !data.printer.state || data.printer.state === 'IDLE') {
                console.log(data);
                document.querySelector("#printStatus").style.display = "none";
                document.querySelector("#featuredContent").style.display = "block";
                {#document.querySelector("#joke").style.display = "block";#}
            } else {
                {#document.querySelector("#featuredContent").style.display = "none";#}
                document.querySelector("#featuredContent").style.display = "none";
                {#document.querySelector("#joke").style.display = "none";#}
                document.querySelector("#printStatus").style.display = "block";
                document.querySelector("#printer-state").textContent = data.printer.state;
                document.querySelector("#printer-temp_nozzle").textContent = data.printer.temp_nozzle;
                document.querySelector("#printer-temp_bed").textContent = data.printer.temp_bed;
                document.querySelector("#printer-axis_z").textContent = data.printer.axis_z;
                if (data.job !== undefined) {
                    document.querySelector("#job-progress").textContent = data.job.progress;
                    document.querySelector("#job-file-display_name").textContent = data.display_name;
                    document.querySelector("#job-time_remaining").textContent = data.job.time_remaining / 60;
                } else {
                    document.querySelector("#job-progress").textContent = "-";
                    document.querySelector("#job-file-display_name").textContent = "No active job";
                    document.querySelector("#job-time_remaining").textContent = "-";
                }
            }

        } catch (error) {
            console.error('There was a problem with fetching printer job data:', error);
        }
    }

    async function fetchBlockBookings() {

        function addBookingToDOM(rooms, booking) {

            // Format XML "2024-08-22T07:30:00+03:00"
            function _time(time) {
                return new Date(time).toLocaleTimeString('fi-FI').slice(0, -3);
            }

            let eventRoom = rooms[booking.room_id - 1];
            // Find the room span with the room id equal to the eventRoom
            let roomSpan = document.getElementById(eventRoom);
            // If the room span does not exist, create it
            if (roomSpan === null) {
                roomSpan = document.createElement("span");
                roomSpan.id = eventRoom;
                document.querySelector("#bookings").appendChild(roomSpan);
                // Line above booking
                roomSpan.appendChild(document.createElement("hr"));
                // create div table  add it to the room span
                let table = document.createElement("div");
                table.className = 'table';
                // create div row add it to the table
                let row = document.createElement("div");
                row.className = 'row';
                table.appendChild(row);
                // create div column add it to the row
                let colLeft = document.createElement("div");
                colLeft.className = 'left-column';
                // vertical alignment of the content in the column is set to center
                colLeft.style.verticalAlign = 'center';
                row.appendChild(colLeft);
                // Room of booking
                let mark = document.createElement("mark");
                mark.textContent = eventRoom;
                colLeft.appendChild(mark);
                // create div column add it to the row
                let colRight = document.createElement("div");
                colRight.className = 'right-column';
                row.appendChild(colRight);
                roomSpan.appendChild(table);
            }

            console.log('roomSpan:');
            console.log(roomSpan)
            console.log(roomSpan.querySelector(".right-column"))
            let rCol = roomSpan.querySelector(".right-column");
            let rightRow = document.createElement("div");
            rightRow.className = 'row-right';
            let leftDiv = Object.assign(document.createElement("div"), {className: 'float-left'});
            // Time of booking
            let time = document.createElement("time");
            time.textContent = _time(booking.start) + " - " + _time(booking.end);
            leftDiv.appendChild(time);
            rightRow.appendChild(leftDiv);

            let rightDiv = Object.assign(document.createElement("div"), {className: 'float-right'});
            // Name of booking
            let summary = document.createElement("summary");
            summary.textContent = booking.title;
            rightDiv.appendChild(summary);
            // Name of booker (to be implemented)
            let article = document.createElement("article");
            article.innerHTML = "&nbsp;";
            // rightDiv.appendChild(article);
            rightRow.appendChild(rightDiv);

            rCol.appendChild(rightRow);

        }

        try {
            const response = await fetch('{{arbs_url}}');
            if (!response.ok) {
                throw new Error('ARBS data fetch failed');
            }
            // Wait for the promise to be resolved
            const data = await response.json();
            console.log('data: ');
            console.log(data);
            // check if data has bookings
            if (!data.error === undefined) {
                console.log('data: ' + data.error);
            } else {
                const rooms = {{ rooms|safe }};
                for (const booking of data) addBookingToDOM(rooms, booking);

                // read the empty bookings template from the file
                async function fetchAndParseEmptyBookings() {
                    try {
                        const response = await fetch('{{ url_for("static", filename="emptyBookings.html") }}');
                        if (!response.ok) {
                            throw new Error('Failed to fetch emptyBookings.html');
                        }
                        const text = await response.text();

                        // Parse the fetched content as an HTML document
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/html');

                        // Select all span elements within the parsed document
                        return Array.from(doc.querySelectorAll('span'));
                    } catch (error) {
                        console.error('Error fetching and parsing emptyBookings.html:', error);
                        return [];
                    }
                }

                // add missing rooms without bookings to the DOM
{#                const emptyBookings = await fetchAndParseEmptyBookings()
                for (const span of emptyBookings) {
                    if (document.getElementById(span.id) === null) {
                        document.querySelector("#bookings").appendChild(span);
                    }
                }#}
                document.getElementById("fallback").style.display = "none";
            }

        } catch (error) {
            console.error('There was a problem with fetching bookings:', error);
            document.getElementById("fallback").style.display = "block";
        }

    }

    // Fetch image every 10 seconds
    setInterval(fetchPrinterImage, 20000);

    // Fetch printer status every 10 seconds
    setInterval(fetchPrinterStatus, 20000);

    fetchBlockBookings()
    // Fetch block bookings once an hour (in ms)
    setInterval(fetchBlockBookings, 3600000);

    let jokes = [];

    function cleanJoke(joke) {
        // Remove numbering and quotation marks
        return joke.replace(/^\d+\.\s*“|”$/g, '').trim();
    }

    async function fetchJokes() {
        try {
            const response = await fetch('/static/jokes.arr');
            if (!response.ok) {
                throw new Error('Failed to fetch jokes');
            }
            const text = await response.text();
            jokes = text.split('\n')
                .map(cleanJoke)
                .filter(joke => joke !== '');
        } catch (error) {
            console.error('Error fetching jokes:', error);
        }
    }

    function setRandomJoke() {
        if (jokes.length > 0) {
            document.querySelector('#joke p').textContent = jokes[Math.floor(Math.random() * jokes.length)];
        }
    }

    // Fetch jokes once on page load
    fetchJokes().then(() => {
        setRandomJoke();
        // Update joke every 10 seconds
        setInterval(setRandomJoke, 10000);
    });
</script>
</html>
